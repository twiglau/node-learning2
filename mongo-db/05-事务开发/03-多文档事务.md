# 多文档事务

对事务的使用原则应该是： 能不用尽量不用。
通过合理地设计文档模型，可以规避绝大部分使用事务的必要性

> 为什么？ 事务 = 锁， 节点协调，额外开销，性能影响。

## MongoDB ACID 多文档事务支持

```lua

事务属性                                 支持程度

Atomocity原子性                          单表单文档：1.x就支持
                                          复制集多表多行： 4.0复制集
                                          分片集群多表多行4.2

Consistency 一致性                       writeConcern, readConcern (3.2)

Isolation 隔离性                         readConcern(3.2)

Durability 持久性                        Journal and Replication
```

## 使用方法

- MongoDB 多文档事务的使用方式与关系数据库非常相似：

```py
try(ClientSession clientSession = client.startSession()) {
  clientSession.startTransaction();
  collection.insertOne(clientSession, docOne);
  collection.insertOne(clientSession, docTwo);
  clientSession.commitTransaction();
}
```

## 事务的隔离级别

- 事务完成前， 事务外的操作 对该事务所做的修改不可访问
- 如果事务内使用 { readConcern: "snapshot"}, 则可以达到可重复读：Repeatable Read

## 实验：启用事务后的 隔离性

```sh
db.tx.insertMany([{x:1}, {x:2}])
var session = db.getMongo().startSession()
session.startTransaction()
var coll = session.getDatabase("test").getCollection("tx")
# 事务内操作 {x:1,y:1}
coll.updateOne({x:1}, {$set: {y:1}})
coll.findOne({x:1})

db.tx.findOne({x:1}) # 事务外的操作{x:1}
session.commitTransaction() # 提交事务
# session.abortTransaction()
```

## 实验：可重复读 Repeatable Read

```sh
var session = db.getMongo().startSession()
session.startTransaction({
  readConcern: { level: "snapshot" },
  writeConcern: { w: "majority" }
});
var coll = session.getDatabase("test").getCollection("tx");

coll.findOne({x:1}) // 返回： {x: 1}  -> Repeatable Read
db.tx.updateOne({x:1},{$set: {y:1}});
db.tx.findOne({x:1}) // 返回：{x: 1, y: 1}
coll.findOne({x:1}) // 返回：{x: 1} -> Repeatable Read
session.commitTransaction();
```

## 事务写机制

- MongoDB 的事务错误处理机制不同于关系数据库:

1. 当一个事务开始后，如果事务要修改的文档在事务外部被修改过，则事务修改这个文档时，会触发 Abort 错误，
   因此此时的修改冲突了；
2. 这种情况下，只需要简单地 重做事务 就可以了；
3. 如果一个事务 已经开始修改一个文档，在事务以外尝试修改同一个文档，则事务以外的修改会等待事务完成，才能
   继续进行

## 实验： 写冲突

- 继续使用上个实验的 tx 集合
- 开两个 mongo shell 均执行下述语句

```sh
var session = db.getMongo().startSession();
session.startTransaction({
  readConcern: { level: "snapshot" },
  writeConcern: { w: "majority" }
});

var coll = session.getDatabase("test").getCollection("tx");
```

```sh
# 窗口1
coll.updateOne({x: 1}, {$set: {y: 1}});
# 正常结束
```

```sh
# 窗口2：
coll.updateOne({x: 1}, {$set: {y: 1}})
# 异常  -解决方案：重启事务
```

## 注意事项

1. 可以实现和关系型数据库类似的事务场景
2. 必须使用与 MongoDB 4.2 兼容的驱动；
3. 事务默认必须在 60s(可调) 内完成，否则将被取消；
4. 设计事务的分片，不能使用仲裁节点；
5. 事务会影响 chunk 迁移效率。正在迁移的 chunk 也可能造成事务提交失败（重试即可）；
6. 多文档事务中的读操作，必须使用主节点 读；
7. readConcern 只应该在事务级别设置，不能设置在每次读写操作上；
