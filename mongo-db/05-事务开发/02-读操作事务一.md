# 读操作事务

在读取数据的过程中我们需要关注以下两个问题：

1. 从哪里读？ 关注数据节点 位置 - 由 readPreference 来解决
2. 什么样的数据可以读？ 关注数据的隔离性 - 由 readConcern 来解决

## 什么是 readPreference ?

readPreference 决定使用哪一个节点来满足正在发起的读请求。可选值包括：

1. primary: 只选择主节点；
2. primaryPreferred: 优先选择主节点，如果不可用，则选择从节点；
3. secondary：只选择从节点；
4. secondaryPreferred: 优先选择从节点，如果从节点不可用，则选择主节点；
5. nearest: 选择最近的节点；

## readPreference 场景

1. 用户下单后后，马上将用户转到订单详情页 - primary/primaryPreferred. 因为此时从节点
   可能还没复制到新订单；
2. 用户查询自己下过的订单 - secondary/secondaryPreferred. 查询历史订单，对时效性通常
   没有太高要求；
3. 生成报表 - secondary. 报表对时效性要求不高，但资源需求大，可以在从节点单独处理，避免
   对线上用户造成影响；
4. 将用户上传的图片分发到全世界，让各地用户能够就近读取 - nearest. 每个地区的应用选择最近
   的节点读取数据；

## readPreference 与 Tag

readPreference 只能控制使用一类节点。 Tag 则可以将节点选择控制到一个多几个节点。考虑以下场景：

- 一个 5 个节点的复制集；
- 3 个节点硬件较好，专用于服务线上用户；
- 2 个节点硬件较差，专用于生成报表；

可以使用 Tag 来达到这样的控制目的：

1. 为 3 个较好的节点打上 { purpose: "online" };
2. 为 2 个较差的节点打上 { purpose: "analyse" };

在线应用读取时指定 online, 报表读取时指定 reporting.

## readPreference 配置

1. 通过 MongoDB 的连接串参数：

```js
const uri =
  "mongodb://host1:27107,host2:27107,host3:27017/?replicaSet=rs&readPreference=secondary";
```

2. 通过 MongoDB 祛痘膏程序 API:

```js
const collection = MongoCollection.withReadPreference(ReadPreference readPref)
```

3. Mongo Shell:

```sh
db.collection.find({}).readPref("secondary")
```

## readPreference 实验： 从节点读

1. 主节点写入 { x: 1}, 观察该条数据在各个节点均可见

```sh
db.test.insert({ x: 1})
primary> db.test.drop()
primary> db.test.find()
primary> db.test.insert({ x: 1 })

secondary> db.test.find()
# {"_id": ObjectId("xxxxxx"), "x": 1 }
primary> db.test.find().readPref("secondary")
# {"_id": ObjectId("xxxxxx"), "x": 1 }
```

2. 在两个从节点分别执行 `db.fsyncLock()` 来锁定写入（同步）

```sh
secondary> db.fsyncLock()
```

3. 主节点写入 { x: 2}

```sh
primary> db.test.insert({x: 2})
primary> db.test.find().readPref("primary")
# { "_id": ObjectId("xxxxxxx"), "x": 1 }
# { "_id": ObjectId("yyyyyyy"), "x": 2 }
primary> db.test.find().readPref("secondary")
# { "_id": ObjectId("xxxxxxx"), "x": 1 }
```

4. 解除从节点锁定 db.fsyncUnlock()

```sh
secondary> db.fsyncUnlock()
secondary> db.test.find()
# { "_id": ObjectId("xxxxxxx"), "x": 1 }
# { "_id": ObjectId("yyyyyyy"), "x": 2 }
primary> db.test.find().readPref("secondary")
# { "_id": ObjectId("xxxxxxx"), "x": 1 }
# { "_id": ObjectId("yyyyyyy"), "x": 2 }
```

## 注意事项

1. 指定 readPreference 时也应注意高可用问题。例如将 readPreference 指定 primary, 则发生故障转移不存在 primary 期间
   没有节点可读。如果业务允许，则应选择 primaryPreferred;
2. 使用 Tag 时也会遇到同样的问题，如果只有一个节点拥有一个特定 Tag, 则在这个节点失效时，将无节点可读。这在有时候是期望的
   结果，有时候不是。例如：

   2.1 如果报表使用的节点失效，即使不生成报表，通常也不希望将报表负载转移到其他节点上，此时只有一个节点有报表 Tag 是合理
   的选择；
   2.2 如果线上节点失效，通常希望有替代节点，所以应该保持多个节点有同样的 Tag;

3. Tag 有时需要与优先级，选举权综合考虑。例如做报表的节点通常不会希望它成为主节点，则优先级应为 0；
