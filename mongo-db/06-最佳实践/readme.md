# 最佳实践

- 连接到 MongoDB
- 查询及索引
- 写入操作
- 文档结构
- 事务

## 连接到 MongoDB

- 正确驱动程序；
- 连接对象 MongoClient:
  > 使用 MongoClient 对象连接到 MongoDB 实例时，总是应该保证它 单例；
  > 并且整个 生命周期 中都从它获取其他操作对象
- 连接字符串
  > 连接字符串中，可以配置大部分连接选项，建议总是在连接字符串中配置
  > 这些选项

```js
// 连接到 复制集
const uri = "mongodb://节点1，节点2,节点3.../database?[options]";
// 连接到 分片集
const uri = "mongodb://mongos1,mongos2,mongos3.../database?[options]";
```

- 常见连接字符串参数

1. maxPoolSize: 连接池大小
2. Max Wait Time: 建议设置，自动杀掉太慢的查询
3. Write Concern: 建议 majority 保证数据安全
4. Read concern: 对于数据一致性要求高的场景适当使用

- 连接字符串节点和地址

1. 无论对于复制集 或 分片集，连接字符串中都应尽可能多地提供节点地址，建议全部列出：

   1.1 复制集利用这些地址，可以更有效地发现集群成员；
   1.2 分片集利用这些地址，可以更有效地分散负载；

2. 连接字符串中尽可能使用与复制集，内部配置相同的域名 或 IP;

## 不要在 mongos 前面使用负载均衡

基于前面提到的原因，驱动已经知晓在不同的 mongos 之间实现负载均衡，而复制集则需要根据节点的角色来
选择发送请求的目标。如果在 mongos 或 复制集 上层部署 负载均衡：

- 驱动会无法探测具体哪个节点存活，从而无法完成自动故障恢复；
- 驱动会无法判断游标是在哪个节点创建的，从而遍历游标时出错；

结论： 不要在 mongos 或 复制集 上层放置负载均衡器，让驱动处理负载均衡 和 自动故障恢复；

## 游标使用

- 如果一个游标已经遍历完，则会自动关闭； 如果没有遍历完，则需要 手动调用 close() 方法；
  否则该游标将在 服务器 上存在 10 分钟（默认值）后超时释放，造成不必要的资源浪费；
- 但是，如果不能遍历完 一个游标，通常意味着 查询条件 太宽泛， 更应该考虑的问题是，如何
  将条件收紧；

## 关于查询及索引

1. 每一个查询都必须要有对应的索引；
2. 尽量使用覆盖索引（Covered Indexes) 可以避免数据文件
3. 使用 projection 来减少返回到 客户端的 文档的内容

## 关于写入

1. 在 update 语句里只包括需要更新的字段
2. 尽可能使用批量插入来提升写入性能
3. 使用 TTL 自动过期日志类型的数据

## 关于文档结构

1. 防止使用太长的字段名（浪费空间）
2. 防止使用太深的数组嵌套（超过 2 层操作，比较复杂）
3. 不使用中文，标点符号等非拉丁字母作为字段名

## 处理分页问题 - 避免使用 count

- 尽可能不要计算总页数，特别是数据量大和查询条件不能完整命中 索引时；
- 考虑以下场景： 假设集合总共有 1000w 条数据，在没有索引的情况下考虑以下查询：

```sh
# 前者只需要遍历前n条， 直到找到 50 条队伍 x=100 的文档，即可结束
db.coll.find({ x:100 }).limit(50);
# 后者需要遍历完 1000w条，找到所有符合要求的文档，才能得到结果
db.coll.count({ x:100 });
```

- 为了计算总页数，而进行的 count() 往往是 拖慢页面整体加载速度的原因

## 处理分页问题 - 巧分页

- 避免使用 skip/limit 形式的分页，特别是数据量大的时候；
- 替代方案： 使用查询条件 + 唯一排序条件；
- 例如：

```sh
# 第一页
db.posts.find({}).sort({_id: 1}).limit(20);
# 第二页
db.posts.find({_id: { $gt: <第一页最后一个_id>}}).sort({_id: 1}).limit(20);
# 第三页
db.posts.find({_id: {$gt: <第二页最后一个_id>}}).sort({_id: 1}).limit(20);
```

## 关于事务 - 使用事务的原则：

1. 无论何时，事务的使用总是能避免则避免；
2. 模型设计先于事务，尽可能用模型设计规避事务；
3. 不要使用过大的事务（尽量控制在 1000 个文档更新以内）;
4. 当必须使用事务时，尽可能让涉及事务的文档分布在 同一个分片上，这将有效地提高效率；
