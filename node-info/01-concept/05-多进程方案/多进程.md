# cluster 模式 以及 PM2 工具的原理介绍

在线上要考虑使用多核 CPU,充分利用服务器资源，这里用到多进程解决方案。

## 单线程问题

- Node.js 主线程是单线程的。如果我们使用 node app.js 方式运行，就启动了一个进程，只能在
  一个 CPU 中进行运算，无法应用服务器的多核 CPU, 因此需要寻求一些解决方案。

## 多进程分发策略

- 主进程接收所有请求，通过一定 【负载均衡策略】 分发到不同的 Node.js 子进程中

1. 主进程监听一个端口， 子进程不监听端口。通过主进程分发请求到子进程。
2. 主进程和子进程分别监听不同端口，通过主进程分发请求到子进程。

## cluster 模式

- cluster 模式其实就是，一个主进程 和 多个子进程，从而形成一个集群的概念。

- Node.js 的 cluster 是如何做到多个进程监听一个端口的?

1. 在 cluster 模式中存在 master 和 worker 的概念，master 就是主进程，
   worker 则是子进程，因此这里需要看下 master 进程和 worket 进程的创建方式

> 通过 send 方法，如果监听到 listening 发送消息给到 主进程，主进程也有同样的
> listening 事件，监听到该事件后将子进程通过 EventEmitter 绑定在主进程上，就
> 完成了主子进程间的 关联绑定， 并且只监听了一个端口。 主子进程间的通信方式是
> IPC 通信方式。

- Node.js 是如何进行负载均衡请求分发的？
  > 涉及 Node.js cluster 模块中的两个模块
  > cluster 模块应用 child_process 创建子进程，通过复写掉 cluster.\_getServer 方法，
  > 在 server.listen 保证只有主进程监听端口，主子进程通过 IPC 进行通信，主进程
  > 根据平台或协议不同，应用两种不同模块（round_robin_handle.js 和 shared_handle.js)
  > 进行请求分发给子进程处理。

1. round_robin_handle.js
   是一个轮询处理模式，也就是轮询调度分发给空闲的子进程，处理完后，回到 worker 空闲
   池子中，注意，如绑定过就会复用该子进程，如果没有则会重新判断，这里可通过上面的 app.js
   代码测试，用浏览器去访问，会发现每次调用的子进程 ID 都会不变。
2. shared_handle.js
   通过将文件描述符，端口等信息传递给子进程，子进程通过信息创建相应的 SocketHandle/ServerHandle
   然后进行相应的端口绑定和监听，处理请求。

## PM2 原理
