# Node.js 高性能是如何做到的

## 事件循环

1. 谁来启动这个循环过程，循环条件是什么？
   1.1 Node.js 事件循环的发起点有 4 个：

   > Node.js 启动后
   > setTimeout 回调函数
   > setInterval 回调函数
   > 也可能是一次 I/O 后的回调函数

2. 循环的是什么任务？
   2.1 timers: 本阶段执行已被 setTimeout()和 setInterval()调度的回调函数，
   由这两个函数启动的回调函数
   2.2 pending callbacks: 本阶段执行某些系统操作的回调函数
   2.3 idle, prepare: 仅系统内部使用（只需知道有这 2 个阶段就可以）
   2.4 poll: 检索新的 I/O 事件，执行与 I/O 相关的回调, 其他情况 Node.js 将在适当时在此阻塞

   > 在 poll 过程中， 主要处理的是异步 I/O 的回调函数， 以及其他几乎所有的回调函数，异步 I/O
   > 又分为 网络 I/O 和 文件 I/O

   2.5 check: setImmediate()回调函数在这个执行。setImmediate 并不是立马执行
   而是当事件循环 poll 中没有新的事件处理时就执行该部分
   2.6 close callbacks: 执行一些关闭的回调函数，如 socket.on('close', ...)

3. 循环任务是否存在优先级概念？

   3.1 宏任务

   > setImmediate, setTimeout/setInterval, setTimeout, 文件 I/O

   没有先后顺序，宏任务执行在微任务后，在同个事件循环周期内，即存在微任务队列又存在宏任务队列，
   那优先将微任务队列清空， 再执行宏任务队列

   3.2 微任务

   > promise, process.nextTick

   微任务在事件循环中优先级是最高的，在同一事件循环中有其他任务存在时，优先执行微任务队列，且 process.nextTick
   和 Promise 也存在优先级， process.nextTick 高于 Promise.

4. 什么进程或者线程来执行这个循环？
5. 无限循环有没有终点？

   > 当所有的微任务和宏任务都清空时，虽然当前没有任何可执行了，但是
   > 也并不能代表循环结束了。

   5.1 可能存在当前还未回调的异步 I/O,所以这个循环是没有终点的，只要进程
   在，并且有新的任务存在，就会去执行。

## 实践验证下 Node.js 的事件驱动，以及 I/O 到底有什么效果和为什么能提高并发 处理能力

> 实验分别从 同步和异步的代码性能分析对比， 得出两者的差异？

1. Node.js 不善于处理 CPU 密集型业务， 就会导致性能问题， 如果要实现一个耗时 CPU 的计算逻辑？

- 用 2 种方法分别计算从 0 到 1000000000000 之间的和，对比各自效果

  > 直接在主业务流程中处理

  ```sh
  time curl http://127.0.0.1:4000 #linux

  curl -w "%{time_total}\n" -o /dev/null -s http://127.0.0.1:4000  #windows
  ```

  > 通过网络异步 I/O 给其他进程处理

- 结果
  两个服务执行时间相差一半，因为异步网络 I/O 充分利用 Node.js 的异步事件驱动能力。
  将耗时 CPU 计算逻辑给其他进程处理，无须等待耗时 CPU 计算，可直接处理其他请求或
  其他部分逻辑，第一种同步执行方式无法处理其逻辑导致性能受到影响。

## Node.js 是单线程，还是多线程？

- 主线程是 单线程执行的，但 Node.js 存在多线程执行，多线程包括： setTimeout 和
  异步 I/O 事件，其实 Node.js 还存在其他线程，包括：垃圾回收，内存优化等。
