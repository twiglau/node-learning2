# 注意点

## I/O 介绍

1. 第一阶段： 读取文件， 将文件放入操作系统内核缓冲区。
2. 第二阶段： 内核缓冲区拷贝到应用程序地址空间。

- 阻塞 I/O

  > 例如读取一个文件，必须要等待文件读取完成后，才能执行其他逻辑，
  > 而当前是无法释放 CPU 的， 因此无法处理其他逻辑。

- 非阻塞 I/O

  > 发起了一个读取文件的指令，系统会返回正在处理中，这是如果要释放进程中的
  > CPU 去处理其他逻辑，就必须间隔一段时间，然后不停去询问操作系统，使用
  > 轮询的判断方法，看是否读取完成了。

- 多路复用 I/O
  > 主要是为了解决轮询调度的问题，可将这些 I/O Socket 处理的结果，统一
  > 交给一个独立线程来处理，当 I/O Socket 处理完成后，就主动告诉业务，处理完成了，
  > 不需要每个业务进行轮询查询。

1. select
   select 是比较旧的，它和 poll 的区别在于 poll 使用的是【链表】来保存 I/O Socket 数据，
   而 select 是 数组， select 会有上限 1024，而 poll 则没有。
2. epoll
   select,poll 与 epoll 的区别在于，前两者不会告诉你是哪个 I/O Socket 完成了，而 epoll
   会通知具体哪个 I/O Socket 完成了哪个阶段的操作。

总结： 这三者 只会告知文件读取进入了操作系统 内核缓冲区。第二阶段从内核拷贝到应用程序地址空间
还是同步等待的。

- 信号驱动 I/O

  > 这种模式和多路复用的区别在于不需要有其他线程来处理，在完成读取进入操作系统内核缓冲区后，
  > 立马通知，第一阶段可由系统层面处理，不需要独立线程来管理，第二阶段和多路复用一样。

- 异步 I/O
  > 异步 I/O 是两个阶段都完成了后，才会通知，不是第一阶段完成。
  > Node.js 是一个异步 I/O ,这个是没有错的。
  > Node.js 是其 libv 库自行实现的一种类似 异步 I/O 的模型，对于 Node.js 应用来说是一个异步 I/O,无须处理
  > 两个过程，而在 libv 内部实现，则是多线程的一个 epoll 模型。
