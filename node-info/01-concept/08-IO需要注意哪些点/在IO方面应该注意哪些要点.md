# 注意点

## I/O 介绍

1. 第一阶段： 读取文件， 将文件放入操作系统内核缓冲区。
2. 第二阶段： 内核缓冲区拷贝到应用程序地址空间。

- 阻塞 I/O

  > 例如读取一个文件，必须要等待文件读取完成后，才能执行其他逻辑，
  > 而当前是无法释放 CPU 的， 因此无法处理其他逻辑。

- 非阻塞 I/O

  > 发起了一个读取文件的指令，系统会返回正在处理中，这是如果要释放进程中的
  > CPU 去处理其他逻辑，就必须间隔一段时间，然后不停去询问操作系统，使用
  > 轮询的判断方法，看是否读取完成了。

- 多路复用 I/O
  > 主要是为了解决轮询调度的问题，可将这些 I/O Socket 处理的结果，统一
  > 交给一个独立线程来处理，当 I/O Socket 处理完成后，就主动告诉业务，处理完成了，
  > 不需要每个业务进行轮询查询。

1. select
   select 是比较旧的，它和 poll 的区别在于 poll 使用的是【链表】来保存 I/O Socket 数据，
   而 select 是 数组， select 会有上限 1024，而 poll 则没有。
2. epoll
   select,poll 与 epoll 的区别在于，前两者不会告诉你是哪个 I/O Socket 完成了，而 epoll
   会通知具体哪个 I/O Socket 完成了哪个阶段的操作。

总结： 这三者 只会告知文件读取进入了操作系统 内核缓冲区。第二阶段从内核拷贝到应用程序地址空间
还是同步等待的。

- 信号驱动 I/O

  > 这种模式和多路复用的区别在于不需要有其他线程来处理，在完成读取进入操作系统内核缓冲区后，
  > 立马通知，第一阶段可由系统层面处理，不需要独立线程来管理，第二阶段和多路复用一样。

- 异步 I/O
  > 异步 I/O 是两个阶段都完成了后，才会通知，不是第一阶段完成。
  > Node.js 是一个异步 I/O ,这个是没有错的。
  > Node.js 是其 libv 库自行实现的一种类似 异步 I/O 的模型，对于 Node.js 应用来说是一个异步 I/O,无须处理
  > 两个过程，而在 libv 内部实现，则是多线程的一个 epoll 模型。

在 Node.js 中如何进行代码优化才能达到极致的性能？
本地磁盘 I/O 注意事项

1. 如果写 I/O,并且不需要获取写入结果时，则不需要进行回调处理，减少主线程压力，比如最常见的例子就是写日志。
2. 如果写 I/O,可以使用文件流的方式，避免重复的打开同一个文件，损耗不必要的打开和关闭文件的过程。
3. 如果写 I/O,为缓解写并发对系统的压力，可将需要写入的日志放入一个临时内存中，从而降低系统并发处理压力，将
   低系统负载。
4. 如果读 I/O,需要获取读取结果时，能使用缓存尽量使用缓存，读 I/O 需要时间，虽不影响主线程性能，但会影响用户
   响应时间，当读 I/O 过大，系统压力较大，从而影响整体读接口的性能，因此需要使用缓存，减少并发对系统的 I/O 压力。
5. 如果读 I/O, 无法进行缓存的，尽量考虑不使用本地磁盘 I/O 操作。
6. 如果读 I/O, 涉及大文件读取操作时，应使用数据流的方式，而不是一次性读取内存中进行处理。

## 日志模块

保存待写入的日志信息，当超出最大保存日志条数时，则直接写入，不保存在日志信息中，主要是避免内存过大，引起垃圾
回收性能问题。

- 定时从临时缓存中，取出数据写入文件中
- 写入文件后，无须处理回调
- 为避免内存占用过大，设置最大文件句柄保存数为 1000 个，每个文件最大的日志临时保存数为 100_000,
  因此最大可能占用的内存为 1000x100000 /1024/1024 ,约等于 100M

```lua

info                          start

_flush                      _intervalWrite <-- setInterval

   |-->       _addLog     <--       |        --> _clean

              |     |
    _getFilePath    _getFileStream
```

1. 会调用 \_flush 判断当前缓存是否已满，或是否开启了缓存，如没有开启或缓存已满，则直接调用 \_addLog 写入日志。 其他情况都写入缓存中。

2. 会定时从临时缓存中获取待写入日志内容，如有则调用 \_addLog 写入日志，写入完后，会调用 \_clean 清理已写入内容，其次会清理未使用的空
   文件流句柄，避免空文件夹，句柄流占用缓存

3. 根据类型获取需要写入的文件路径，并调用 \_getFileStream 来获取文件流句柄，这里就会用到文件流缓存，当缓存有，则返回，没有则创建一个文件
   流句柄

可能会丢失日志，主要在写入日志完成后，还没清理，又有数据写入临时缓存中，导致部分丢失的现象，默认情况下，允许这种情况。
因为这种丢失的现象概率比较低。

## 网络 I/O,

在后台服务中常见的网络 I/O,有如下几种类型：

1. 缓存型，如 MemCache,Redis
2. 数据存储型，如 MySQL,MongoDB
3. 服务型，如 内网 API 服务或者第三方 API

网络 I/O 的成本是最高的，因为会涉及两个最重要的点：

1. 依赖其他服务的性能
2. 依赖服务器之间的延时

如何避免：

1. 减少与网络 I/O 的交互， 比如缓存已获取的内容

- 对于一些与用户维度不相关的数据，或批次用户数据类似的情况，可通过网络 I/O 获取数据后，
  缓存在本地服务器上，后面只需从本地内存中读取即可
- 本地缓存对这种固定化，无用户差别的数据，是可以进行缓存的，而且非常有必要，比如，常见
  的一些客户端配置化信息
- 本地内存缓存最大的问题点：
  > 每台机器可能缓存了不同的数据
  > 每台机器缓存运营配置，这是运营修改了配置，不同机器过期时间不一致，导致用户每次刷新
  > 可能出现不同首页配置，需要高性能替换方案来解决

2. 使用更 高性能的网络 I/O,替代其他性能较差的，成本更高的 网络 I/O 类型。

- 本地缓存时直接本地内存，性能搞过共享内存，也就是网络 I/O 中共享内存方式，但网络 I/O 共享内存
  的性能高于网络 I/O 中的磁盘 I/O 性能，如 Redis 的性能是远高于 MySQL 的，前两者是 共享内存 的方式，
  内存操作时快于磁盘 I/O,因此可通过 MySQL 获取数据后保存在高性能 网络 I/O 的 Redis 上，可大大提升性能。
  其次共享内存方案也可解决本地缓存中数据不一致的问题。
- 共享内存适合那些可以延迟更新的数据服务，并且与用户维度无关，每个用户（或者有限用户分类）拉取的内容都是
  一致的，如果每个用户内容不一致，会导致缓存命中较低，同时浪费大量的内存空间。

3. 降低目标网络 I/O 服务的并发压力， 可以采用 异步队列方式。

用户抢票例子：
如果每个用户抢票，都执行一次查询，确购票。那对目标机器压力非常大，像 12306 几亿人同时抢的情况，这里就
可采用 异步队列方式， 用户发送请求后，只告知用户，已经进入队列，但真正情况是：用户请求会缓存在一个队列中，
在逐一前往具体网络 I/O 服务中，独立处理。 这时并发压力可控，也不会出现性能问题。

- 异步队列一个较高性能的网络 I/O, 通过一个高性能网络 I/O,将其他业务逻辑封装，让用户无感知，只是延迟了
  用户收到结果的时间。

## pm2 启动

```sh
pm2 start pm2.config.js --env development
pm2 start pm2.config.js --env testing
pm2 start pm2.config.js --env production
```
