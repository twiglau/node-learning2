# 什么是内存泄漏，当出现内存异常时，应如何去分析并定位具体的问题。

## 内存泄漏

指程序中已动态分配的堆内存，由于某种原因程序未释放或无法释放，造成系统内存的浪费。导致程序运行速度减慢
甚至系统崩溃等严重后果。

## Node.js GC 的策略

### 由于栈是系统存储的临时数据，系统会进行释放，不会引发内存泄漏问题。堆中的数据是需程序自己进行清理，存在内存泄漏风险，在 JavaScript 中，进行垃圾回收的有：引用计数和标记清除法。

1. 栈
   栈中主要存储的是一些原始类型，比如：Boolean,Null,Undefined,Number,BigInt,String 以及 Symbol
2. 堆
   堆中主要存储引用类型的数据，比如对象，全局变量等。

### 在 Node.js V8 引擎中使用了多种方法的融合：

1. 对于存活较短的存储对象会使用 Scavenge 算法。
2. 对于存活较长的对象，或者说在 Scavenge 算法中存储的对象数据超过一定比例时，会使用：标记清除法和标记整理法，相结合的方式。

## 内存泄漏分类

常发性，偶发性，一次性，和隐性。

1. 常发性
   发生内存泄漏的代码会被多次执行，每次执行的时候会导致一块内存泄漏

   > 比如：有个全局变量，在每次调用该部分业务逻辑时，都会导致该变量
   > 的数据增加，这就是常发性。

2. 偶发性
   发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。

   > 对于特定的环境，偶发性也许就变成了常发性，比如：虽然都是全局变量，A 逻辑只要调用
   > 就会增加，而 B 逻辑需要满足各种复杂条件后才会增加，那么 B 就是偶发性，而 A 就是上面
   > 的常发性。

3. 一次性
   发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块且仅一块内存发生泄漏

   > 比如： 在启动 Node.js 服务后，require 并初始化了一个对象，但没在程序中使用这个对象。在 Node.js
   > require 的模块会被缓存起来，这也算是一种内存泄漏场景。只是这类场景影响有限。

4. 隐性
   在调用函数或模块时，当参数或输入没有达到界定值时，是不会发生泄漏，当参数或输入达到一定值时，才会发现内存泄漏。
   > 比如： 读取一个文件，当文件很小时，内存可以处理，但当读取文件非常大，则导致内存异常问题，严格来说隐性的
   > 情况并不是内存泄漏，因为当程序调用结束时，还是会最终释放。

## Node.js 内存泄漏分析方法

- 如果内存泄漏是常发性的，这就不需要到生产环境（现网环境)复现了，可以直接在开发或测试环境进行内存快照即可。
  而如果是偶发性的，或隐性的情况，才需要再生产环境进行内存快照。

- 工具：

1. heapdump 内存快照的工具。
2. chrome dev tools 中的 Memory Profiles
